#include <Arduino.h>
#include <Wire.h>
#include <SPI.h>
#include <Adafruit_GFX.h>
#include <Adafruit_ST7735.h>
#include <AnimatedGIF.h>
#include <LittleFS.h>

// --- PINY ---
#define TFT_BLK   48
#define TFT_SDA   45
#define TFT_SCL   39
#define TFT_DC    37
#define TFT_RST   40

// Przyciski
#define SWITCH_PIN   9
#define SWITCH_PIN_2 7
#define SWITCH_PIN_3 5
#define SWITCH_PIN_4 35
#define SWITCH_PIN_5 41
#define SWITCH_PIN_6 2

// Chip Select (CS) dla każdego ekranu
#define TFT_CS    38
#define TFT_CS_2  42  
#define TFT_CS_3  4
#define TFT_CS_4  18
#define TFT_CS_5  8
#define TFT_CS_6  11

// Obiekty
Adafruit_ST7735* tft[6];
int ekrany[6] = {TFT_CS, TFT_CS_2, TFT_CS_3, TFT_CS_4, TFT_CS_5, TFT_CS_6};
int klawisze[6] = {SWITCH_PIN, SWITCH_PIN_2, SWITCH_PIN_3, SWITCH_PIN_4, SWITCH_PIN_5, SWITCH_PIN_6};

AnimatedGIF gif;
int aktualnyEkranDoGifa = 0;

// ==========================================
// --- FUNKCJA RYSOWANIA (CALLBACK) ---
// ==========================================
void GIFDraw(GIFDRAW *pDraw) {
  uint8_t *s;
  uint16_t *d, *usPalette, usTemp[320];
  int x, y, iWidth;

  iWidth = pDraw->iWidth;
  if (iWidth > 160) iWidth = 160;

  usPalette = pDraw->pPalette;
  y = pDraw->iY + pDraw->y;
  
  s = pDraw->pPixels;
  if (pDraw->ucDisposalMethod == 2) {
    for (x = 0; x < iWidth; x++) {
      if (s[x] == pDraw->ucTransparent) s[x] = pDraw->ucBackground;
    }
    pDraw->ucHasTransparency = 0;
  }

  if (pDraw->ucHasTransparency) {
    uint8_t *pEnd, c, ucTransparent = pDraw->ucTransparent;
    int iOffset = 0;
    pEnd = s + iWidth;
    while (s < pEnd) {
      c = *s++;
      if (c == ucTransparent) {
        s--;
        d = usTemp;
        while (s < pEnd && *s == ucTransparent) { s++; iOffset++; }
      } else {
        d = usTemp;
        while (s < pEnd && *s != ucTransparent) { *d++ = usPalette[*s++]; }
        tft[aktualnyEkranDoGifa]->drawRGBBitmap(pDraw->iX + iOffset, y, usTemp, (d - usTemp), 1);
        iOffset += (d - usTemp);
      }
    }
  } else {
    s = pDraw->pPixels;
    for (x = 0; x < iWidth; x++) {
      usTemp[x] = usPalette[*s++];
    }
    tft[aktualnyEkranDoGifa]->drawRGBBitmap(pDraw->iX, y, usTemp, iWidth, 1);
  }
}

// ==========================================
// --- FUNKCJA ODTWARZANIA (WERSJA RAM) ---
// ==========================================
void odtworzGifNaEkranie(int numerEkranu, const char* nazwaPliku) {
  aktualnyEkranDoGifa = numerEkranu;
  
  // 1. Otwórz plik
  File f = LittleFS.open(nazwaPliku, "r");
  if (!f) {
    Serial.print("Błąd: Nie znaleziono pliku "); Serial.println(nazwaPliku);
    return;
  }

  // 2. Pobierz rozmiar
  size_t rozmiarPliku = f.size();
  Serial.print("Wczytuje plik: "); Serial.print(nazwaPliku);
  Serial.print(" Rozmiar: "); Serial.println(rozmiarPliku);

  if (rozmiarPliku > 150000) { // Zabezpieczenie przed zbyt dużymi plikami (>150KB)
      Serial.println("Błąd: Plik za duży do RAM!");
      f.close();
      return;
  }

  // 3. Zarezerwuj pamięć RAM (malloc)
  uint8_t *gifBuffer = (uint8_t*)malloc(rozmiarPliku);
  if (gifBuffer == NULL) {
    Serial.println("Błąd: Brak pamięci RAM!");
    f.close();
    return;
  }

  // 4. Wczytaj cały plik do bufora
  f.read(gifBuffer, rozmiarPliku);
  f.close(); // Plik na dysku nie jest już potrzebny

  // 5. Odtwórz GIF z pamięci RAM
  // Używamy open() dla bufora pamięci, nie dla pliku!
  if (gif.open(gifBuffer, rozmiarPliku, GIFDraw)) {
    Serial.println("GIF otwarty, odtwarzam...");
    
    while (gif.playFrame(true, NULL)) {
       // Pętla kręci się dopóki są klatki
    }
    
    gif.close();
    Serial.println("Koniec odtwarzania.");
  } else {
    Serial.println("Błąd: Nie udało się zdekodować GIFa.");
  }

  // 6. Zwolnij pamięć (Bardzo ważne!)
  free(gifBuffer);
  Serial.println("Pamięć zwolniona.");
}

// ==========================================
// --- SETUP ---
// ==========================================
void setup() {
  Serial.begin(9600);
  
  // 1. Inicjalizacja LittleFS
  if (!LittleFS.begin(false)) {
    Serial.println("Błąd LittleFS! Próbuję formatować...");
    if(!LittleFS.begin(true)){
        Serial.println("Krytyczny błąd LittleFS!");
    }
  }

  // 2. Hardware SPI
  SPI.begin(TFT_SCL, -1, TFT_SDA, -1);

  Serial.println("--- START SYSTEMU ---");
  
  // 3. Reset ekranów
  pinMode(TFT_BLK, OUTPUT);
  digitalWrite(TFT_BLK, HIGH);

  pinMode(TFT_RST, OUTPUT);
  digitalWrite(TFT_RST, HIGH); delay(50);
  digitalWrite(TFT_RST, LOW);  delay(50);
  digitalWrite(TFT_RST, HIGH); delay(150);
  
  // 4. Konfiguracja ekranów
  for (int i = 0; i < 6; i++) {
    pinMode(ekrany[i], OUTPUT);
    digitalWrite(ekrany[i], HIGH);
  }
  
  for (int i = 0; i < 6; i++) {
    tft[i] = new Adafruit_ST7735(ekrany[i], TFT_DC, -1);
    tft[i]->initR(INITR_MINI160x80);
    tft[i]->setRotation(3);
    tft[i]->invertDisplay(false);
    if (i > 2) {
      tft[i]->setRotation(1);
    }
  }

  // 5. Klawisze
  for (int i = 0; i < 6; i++) {
    pinMode(klawisze[i], INPUT_PULLUP);
  }

  // 6. Inicjalizacja GIF
  gif.begin(GIF_PALETTE_RGB565_LE);

  tft[0]->fillScreen(ST77XX_BLUE);
  Serial.println("Gotowe!");
}

// ==========================================
// --- LOOP ---
// ==========================================
void loop() {
  if (digitalRead(SWITCH_PIN) == LOW) {
    // Uwaga: To blokuje działanie reszty programu na czas trwania gifa
    odtworzGifNaEkranie(0, "/1.gif");
    delay(200); 
  }
  
  if (digitalRead(SWITCH_PIN_2) == LOW) {
      odtworzGifNaEkranie(1, "/2.gif");
      delay(200);
  }
  
  // itd...
  delay(50);
}